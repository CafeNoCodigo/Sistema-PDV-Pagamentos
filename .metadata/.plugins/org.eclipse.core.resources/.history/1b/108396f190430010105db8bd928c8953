package com.minhaloja.sistema_pagamento.controller;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.minhaloja.sistema_pagamento.dao.CaixaDAO;
import com.minhaloja.sistema_pagamento.dao.FuncionarioDAO;
import com.minhaloja.sistema_pagamento.util.NotificacaoSistema;
import com.minhaloja.sistema_pagamento.util.WindowManager;

import javafx.animation.*;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.stage.Stage;
import javafx.util.Duration;

public class telaInicialController {

    @FXML private Button btnFechar;
    @FXML private Button btnAtualizar;
    
    @FXML private ChoiceBox<String> choiceFuncionario;
    @FXML private Label labelAnimada;

    private final FuncionarioDAO funcionarioDAO = new FuncionarioDAO();
    private final CaixaDAO caixaDAO = new CaixaDAO();

    private final String textoAnimado = "F P S  ";
    private int indiceTexto = 0;
    private Timeline timeline;

    @FXML
    public void initialize() {
        carregarFuncionariosNoChoiceBox();
        iniciarAnimacaoLabel();
        aplicarAnimacoesComponentes();
     
    	String msg = "EXISTE UM CAIXA ABERTO!";
    	popUp(msg);	
     
    }
        private static final String VERSAO_ATUAL = "1.0.0";

        // Substitua com os IDs corretos dos arquivos no Google Drive
        private static final String ID_VERSAO_TXT = "1OH-yz2IAL55Vt0N5zJBp6KN-No1Fecf4";
        private static final String ID_ARQUIVO_ATUALIZACAO = "1OH-yz2IAL55Vt0N5zJBp6KN-No1Fecf4";

        @SuppressWarnings({ "deprecation", "deprecation" })
		@FXML
        private void atualizar() {
                try {
                    String versaoOnline = baixarVersaoOnline();
                    if (!VERSAO_ATUAL.equals(versaoOnline)) {
                        mostrarAlerta("Atualização encontrada", "Nova versão: " + versaoOnline + "\nBaixando...");

                        String caminhoArquivo = "atualizacao_download"; // sem extensão
                        String caminhoCompleto = baixarArquivoAtualizacao(caminhoArquivo);

                        if (caminhoCompleto.endsWith(".zip")) {
                            descompactarZip(caminhoCompleto, ".");
                            mostrarAlerta("Atualização Concluída", "Arquivos atualizados com sucesso.");
                            relancarApp(); // apenas relança, se quiser
                        } else if (caminhoCompleto.endsWith(".exe")) {
                            Runtime.getRuntime().exec("cmd /c start \"\" \"" + caminhoCompleto + "\"");
                            mostrarAlerta("Instalador Iniciado", "O instalador foi aberto. Fechando o app...");
                            fecharApp();
                        } else {
                            mostrarAlerta("Erro", "Tipo de arquivo não suportado.");
                        }

                    } else {
                        mostrarAlerta("Sem atualizações", "Você já está na versão mais recente.");
                    }

                } catch (Exception ex) {
                    ex.printStackTrace();
                    mostrarAlerta("Erro", "Erro ao verificar/baixar atualização:\n" + ex.getMessage());
                }
        }

        @SuppressWarnings("deprecation")
		private String baixarVersaoOnline() throws IOException {
            String url = "https://drive.google.com/uc?export=download&id=" + ID_VERSAO_TXT;
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL(url).openStream()))) {
                return reader.readLine().trim();
            }
        }

        @SuppressWarnings("deprecation")
		private String baixarArquivoAtualizacao(String nomeBase) throws IOException {
            String url = "https://drive.google.com/uc?export=download&id=" + ID_ARQUIVO_ATUALIZACAO;
            String tempFile = nomeBase + ".tmp";

            try (InputStream in = new URL(url).openStream()) {
                Files.copy(in, Paths.get(tempFile), StandardCopyOption.REPLACE_EXISTING);
            }

            // Detectar extensão real do arquivo (zip ou exe)
            String novaExtensao = detectarExtensaoArquivo(tempFile);
            String nomeFinal = nomeBase + novaExtensao;
            Files.move(Paths.get(tempFile), Paths.get(nomeFinal), StandardCopyOption.REPLACE_EXISTING);

            return nomeFinal;
        }

        private String detectarExtensaoArquivo(String caminhoArquivo) throws IOException {
            try (InputStream in = new FileInputStream(caminhoArquivo)) {
                byte[] magic = new byte[4];
                in.read(magic);

                // Assinaturas de arquivos comuns
                if (magic[0] == 'M' && magic[1] == 'Z') return ".exe"; // Windows Executável
                if (magic[0] == 'P' && magic[1] == 'K') return ".zip"; // Arquivo ZIP

                return ".dat"; // Desconhecido
            }
        }

        private void descompactarZip(String zipPath, String destino) throws IOException {
            try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipPath))) {
                ZipEntry entry;
                while ((entry = zipIn.getNextEntry()) != null) {
                    Path filePath = Paths.get(destino, entry.getName());
                    if (!entry.isDirectory()) {
                        Files.createDirectories(filePath.getParent());
                        Files.copy(zipIn, filePath, StandardCopyOption.REPLACE_EXISTING);
                    }
                    zipIn.closeEntry();
                }
            }
        }

        private void mostrarAlerta(String titulo, String mensagem) {
            Platform.runLater(() -> {
                Alert alert = new Alert(Alert.AlertType.INFORMATION);
                alert.setTitle(titulo);
                alert.setHeaderText(null);
                alert.setContentText(mensagem);
                alert.showAndWait();
            });
        }

        private void fecharApp() {
            Platform.exit();
            System.exit(0);
        }

        private void relancarApp() {
            // Se quiser relançar o app após atualizar, pode chamar novamente o executável.
            // Exemplo:
            // Runtime.getRuntime().exec("cmd /c start javaw -jar MeuApp.jar");
            fecharApp();
        }

    private void iniciarAnimacaoLabel() {
        
        timeline = new Timeline(
            new KeyFrame(Duration.millis(600), e -> {
                if (indiceTexto <= textoAnimado.length()) {
                    labelAnimada.setText(textoAnimado.substring(0, indiceTexto));
                    indiceTexto++;
                } else {
                    indiceTexto = 0;
                    labelAnimada.setText("");
                }
            })
        );
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }

    private void aplicarAnimacoesComponentes() {
        
        btnFechar.addEventHandler(MouseEvent.MOUSE_ENTERED, e -> {
            ScaleTransition scaleUp = new ScaleTransition(Duration.millis(200), btnFechar);
            scaleUp.setToX(1.05);
            scaleUp.setToY(1.05);
            scaleUp.play();
        });

        btnFechar.addEventHandler(MouseEvent.MOUSE_EXITED, e -> {
            ScaleTransition scaleDown = new ScaleTransition(Duration.millis(200), btnFechar);
            scaleDown.setToX(1.0);
            scaleDown.setToY(1.0);
            scaleDown.play();
        });

        // Efeito pulse contínuo
        ScaleTransition pulse = new ScaleTransition(Duration.seconds(1.5), btnFechar);
        pulse.setFromX(1.0);
        pulse.setFromY(1.0);
        pulse.setToX(1.03);
        pulse.setToY(1.03);
        pulse.setCycleCount(Animation.INDEFINITE);
        pulse.setAutoReverse(true);
        pulse.play();
    }

    @FXML
    private void carregarFuncionariosNoChoiceBox() {
        List<String> nomes = funcionarioDAO.listarFuncionariosChoiceBox();
        choiceFuncionario.getItems().setAll(nomes);
    }

    @FXML
    private void fecharJanela() {
    	if (caixaDAO.isCaixaAberto()) {
        	String msg = "Teste de Atualizacao";
            NotificacaoSistema notificacao = new NotificacaoSistema();
            notificacao.mostrarNotificacaoPopUp(msg);
        }
        Stage stage = (Stage) btnFechar.getScene().getWindow();
        stage.close();

        // Finaliza a aplicação completamente
        javafx.application.Platform.exit();
        System.exit(0);
    }
    
    public void abrirTelaCadastroCliente() {
    	WindowManager.abrirTelaCadastroCliente();
    }
    
    public void abrirTelaFormaPagamento() {
        WindowManager.abrirTelaFormaPagamento();
    }

    public void abrirTelaCadastroProduto2() {
        WindowManager.abrirTelaCadastroProduto();
    }

    public void abrirTelaFluxoCaixa2() {
        WindowManager.abrirTelaFluxoCaixa();
    }

    public void abrirTelaCadastroFuncionario2() {
        WindowManager.abrirTelaCadastroFuncionario();
    }

    public void abrirTelaVenda2() {
        WindowManager.abrirTelaVenda();
    }

    public void abrirTelaEstoqueAtual2() {
        WindowManager.abrirTelaEstoqueAtual();
    }

    public void abrirTelaRelatorio2() {
        WindowManager.abrirTelaRelatorio();
    }

    public void abrirTelaRequisicao2() {
        WindowManager.abrirTelaRequisicao();
    }
    
    private void popUp(String msg) {
    	if (caixaDAO.isCaixaAberto()) {
            NotificacaoSistema notificacao = new NotificacaoSistema();
            notificacao.mostrarNotificacaoPopUp(msg);
        }
    }
}
